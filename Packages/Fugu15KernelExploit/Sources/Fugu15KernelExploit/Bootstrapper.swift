import CBindings;
import PatchfinderUtils;

public enum BootstrapError: Error {
	case custom(_: String)
}


public class Bootstrapper {
	static func remountPrebootPartition(writable: Bool) -> Int32? {
		if writable {
			return execCmd(args: ["/sbin/mount", "-u", "-w", "/private/preboot"])
		} else {
			return execCmd(args: ["/sbin/mount", "-u", "/private/preboot"])
		}
	}
    
    static func zstdDecompress(zstdPath: String, targetTarPath: String) -> Int32 {
        return decompress_tar_zstd(zstdPath, targetTarPath)
    }
	
	static func untar(tarPath: String, target: String) -> Int32? {
		let tarBinary = Bundle.main.bundlePath + "/tar"
		try? FileManager.default.setAttributes([.posixPermissions: 0o755], ofItemAtPath: tarBinary)
		return execCmd(args: [tarBinary, "-xpkf", tarPath, "-C", target]);
	}

	static func getBootManifestHash() -> String? {
		let registryEntry = IORegistryEntryFromPath(kIOMainPortDefault, "IODeviceTree:/chosen")
		if registryEntry == MACH_PORT_NULL {
			return nil
		}
		guard let bootManifestHash = IORegistryEntryCreateCFProperty(registryEntry, "boot-manifest-hash" as CFString, kCFAllocatorDefault, 0) else {
			return nil
		}
		guard let bootManifestHashData = bootManifestHash.takeRetainedValue() as? Data else {
			return nil
		}
		return bootManifestHashData.map { String(format: "%02X", $0) }.joined()
	}

	static func UUIDPathPermissionFixup() throws {
		let UUIDPath = "/private/preboot/" + getBootManifestHash()!

		var UUIDPathStat = stat()
		if stat(UUIDPath, &UUIDPathStat) != 0 {
			throw BootstrapError.custom("Failed to stat \(UUIDPath): (\(String(cString: strerror(errno))))")
		}

		let curOwnerID = UUIDPathStat.st_uid
		let curGroupID = UUIDPathStat.st_gid
		if curOwnerID != 0 || curGroupID != 0 {
			if chown(UUIDPath, 0, 0) != 0 {
				throw BootstrapError.custom("Failed to chown 0:0 \(UUIDPath): (\(String(cString: strerror(errno))))")
			}
		}

		let curPermissions = UUIDPathStat.st_mode & S_IRWXU
		if curPermissions != 0o755 {
			if chmod(UUIDPath, 0o755) != 0 {
				throw BootstrapError.custom("Failed to chmod 755 \(UUIDPath): (\(String(cString: strerror(errno))))")
			}
		}
	}

	public static func locateExistingFakeRoot() -> String? {
		let ppURL = URL(fileURLWithPath: "/var/containers/Bundle/Application")
		guard let candidateURLs = try? FileManager.default.contentsOfDirectory(at: ppURL , includingPropertiesForKeys: nil, options: []) else { return nil }
		for candidateURL in candidateURLs {
			if candidateURL.lastPathComponent.hasPrefix(".jbroot-") {
                let JBRAND = candidateURL.lastPathComponent.suffix(16);
                if !checkJBRAND(String(JBRAND)) { continue }
                cachedBootInfo["JBRAND"] = JBRAND
                cachedBootInfo["JBROOT"] = "/var/containers/Bundle/Application/.jbroot-" + JBRAND
				return candidateURL.path
			}
		}
		return nil
	}
    
    static func generateFakeRootPath() -> String {
        let result = generateJBRAND()!
        cachedBootInfo["JBRAND"] = result
        cachedBootInfo["JBROOT"] = "/var/containers/Bundle/Application/.jbroot-" + result
        return "/var/containers/Bundle/Application/.jbroot-" + result
    }

	static func wipeSymlink(atPath path: String) {
		let fileManager = FileManager.default
		do {
			let attributes = try fileManager.attributesOfItem(atPath: path)
			if let fileType = attributes[.type] as? FileAttributeType, fileType == .typeSymbolicLink {
				try fileManager.removeItem(atPath: path)
				Logger.print("Deleted symlink at \(path)")
			} else {
				//Logger.print("Wanted to delete symlink at \(path), but it is not a symlink")
			}
		} catch _ {
			//Logger.print("Wanted to delete symlink at \(path), error occured: \(error), but we ignore it")
		}
	}

	static func fileOrSymlinkExists(atPath path: String) -> Bool {
		let fileManager = FileManager.default
		if fileManager.fileExists(atPath: path) {
			return true
		}
		do {
			let attributes = try fileManager.attributesOfItem(atPath: path)
			if let fileType = attributes[.type] as? FileAttributeType, fileType == .typeSymbolicLink {
				return true
			}
		} catch _ { }

		return false
	}

	static func createSymbolicLink(atPath path: String, withDestinationPath pathContent: String) throws {
		let components = path.split(separator: "/")
		let directoryPath = components.dropLast(1).map(String.init).joined(separator: "/")
		if !FileManager.default.fileExists(atPath: directoryPath) {
			try FileManager.default.createDirectory(atPath: directoryPath, withIntermediateDirectories: true, attributes: nil)
		}
		try FileManager.default.createSymbolicLink(atPath: path, withDestinationPath: pathContent)
	}

	static func extractBootstrap() throws {
//		let jbPath = "/var/jb"

//		if remountPrebootPartition(writable: true) != 0 {
//			throw BootstrapError.custom("Failed to remount /private/preboot partition as writable")
//		}
//		try UUIDPathPermissionFixup()
		
        // Remove existing /var/jb symlink if it exists (will be recreated later)
//        wipeSymlink(atPath: jbPath)
//        if FileManager.default.fileExists(atPath: jbPath) {
//            try FileManager.default.removeItem(atPath: jbPath)
//        }

		// If xina was used before, clean the mess it creates in /var
		// Xina will recreate them on the next jb through it so there is no loss here
		let xinaLeftoverSymlinks = [
            "/var/jb",
			"/var/alternatives",
			"/var/ap",
			"/var/apt",
			"/var/bin",
			"/var/bzip2",
			"/var/cache",
			"/var/dpkg",
			"/var/etc",
			"/var/gzip",
			"/var/lib",
			"/var/Lib",
			"/var/libexec",
			"/var/Library",
			"/var/LIY",
			"/var/Liy",
			"/var/local",
			"/var/newuser",
			"/var/profile",
			"/var/sbin",
			"/var/suid_profile",
			"/var/sh",
			"/var/sy",
			"/var/share",
			"/var/ssh",
			"/var/sudo_logsrvd.conf",
			"/var/suid_profile",
			"/var/sy",
			"/var/usr",
			"/var/zlogin",
			"/var/zlogout",
			"/var/zprofile",
			"/var/zshenv",
			"/var/zshrc",
			"/var/log/dpkg",
			"/var/log/apt"
		]
		let xinaLeftoverFiles = [
			"/var/lib", //sometimes is a symlink, sometimes is not(?)
			"/var/master.passwd"
		]

		//if !FileManager.default.fileExists(atPath: "/var/.keep_symlinks") {
			for xinaLeftoverSymlink in xinaLeftoverSymlinks {
				wipeSymlink(atPath: xinaLeftoverSymlink)
			}
			for xinaLeftoverFile in xinaLeftoverFiles {
				if FileManager.default.fileExists(atPath: xinaLeftoverFile) {
					try FileManager.default.removeItem(atPath: xinaLeftoverFile)
				}
			}
		//}
		
		// Ensure fake root directory inside /private/preboot exists
		var fakeRootPath = locateExistingFakeRoot()
		if fakeRootPath == nil {
            Logger.print("Status: Randomize Jailbreak Directory")
			fakeRootPath = generateFakeRootPath()
			try FileManager.default.createDirectory(atPath: fakeRootPath!, withIntermediateDirectories: true)
            chown(fakeRootPath!, 0, 0)
        } else {
            Logger.print("Status: Re-randomize Jailbreak Directory")
            wipeSymlink(atPath: cachedBootInfo["JBROOT"] as! String)
            
            let oldJBRAND = cachedBootInfo["JBRAND"]
            
            //re-randomize, rebuild cachedBootInfo info
            let fakeRootPathNew = generateFakeRootPath()
            try FileManager.default.moveItem(atPath: fakeRootPath!, toPath: fakeRootPathNew)
            fakeRootPath = fakeRootPathNew
            
            // upgrade to 1.0.3
            chown(fakeRootPathNew, 0, 0)
            chown("/var/mobile/Containers/Data/Application/.jbroot-"+(oldJBRAND as! String), 0, 0)
            try? FileManager.default.moveItem(atPath: "/var/mobile/Containers/Data/Application/.jbroot-"+(oldJBRAND as! String),
                                             toPath: "/var/mobile/Containers/Shared/AppGroup/.jbroot-"+(oldJBRAND as! String))
            
            // re-randomize seconday jbroot
            try FileManager.default.moveItem(atPath: "/var/mobile/Containers/Shared/AppGroup/.jbroot-"+(oldJBRAND as! String),
                                             toPath: "/var/mobile/Containers/Shared/AppGroup/.jbroot-"+(cachedBootInfo["JBRAND"] as! String))
        }
		
		// Extract Procursus Bootstrap if neccessary
		var bootstrapNeedsExtract = false
		let procursusPath = fakeRootPath! // + "/procursus"
		let installedPath = procursusPath + "/.installed_dopamine"
		let prereleasePath = procursusPath + "/.used_dopamine_prerelease"

		if FileManager.default.fileExists(atPath: procursusPath) {
			if !FileManager.default.fileExists(atPath: installedPath) {
				Logger.print("Wiping existing bootstrap because installed file not found")
				try FileManager.default.removeItem(atPath: procursusPath)
			}
			if FileManager.default.fileExists(atPath: prereleasePath) {
				Logger.print("Wiping existing bootstrap because pre release")
				try FileManager.default.removeItem(atPath: procursusPath)
			}
		}
		if !FileManager.default.fileExists(atPath: procursusPath) {
			try FileManager.default.createDirectory(atPath: procursusPath, withIntermediateDirectories: true)
            chown(procursusPath, 0, 0)
			bootstrapNeedsExtract = true
		}
        
		
		// Update basebin (should be done every rejailbreak)
		if FileManager.default.fileExists(atPath: procursusPath + "/basebin") {
			try FileManager.default.removeItem(atPath: procursusPath + "/basebin")
		}
        let basebinTarPath = Bundle.main.bundlePath + "/basebin.tar"
		let untarRet = untar(tarPath: basebinTarPath, target: procursusPath)
		if untarRet != 0 {
			throw BootstrapError.custom(String(format:"Failed to untar Basebin: \(String(describing: untarRet))"))
		}
        
        let seconday = "/var/mobile/Containers/Shared/AppGroup/.jbroot-\(cachedBootInfo["JBRAND"] as! String)"
        if !FileManager.default.fileExists(atPath: seconday) {
            try FileManager.default.createDirectory(atPath: seconday, withIntermediateDirectories: true)
            chown(seconday, 0, 0)
        }
        
		// Extract Procursus if needed
		if bootstrapNeedsExtract {
			let bootstrapZstdPath = Bundle.main.bundlePath + "/bootstrap-iphoneos-arm64.tar.zst"
            let bootstrapTmpTarPath = NSTemporaryDirectory() + "/bootstrap-iphoneos-arm64.tar"
            if FileManager.default.fileExists(atPath: bootstrapTmpTarPath) {
                try FileManager.default.removeItem(atPath: bootstrapTmpTarPath);
            }
            let zstdRet = zstdDecompress(zstdPath: bootstrapZstdPath, targetTarPath: bootstrapTmpTarPath)
            if zstdRet != 0 {
                throw BootstrapError.custom(String(format:"Failed to decompress bootstrap: \(String(describing: zstdRet))"))
            }
			let untarRet = untar(tarPath: bootstrapTmpTarPath, target: procursusPath)
            try FileManager.default.removeItem(atPath: bootstrapTmpTarPath);
			if untarRet != 0 {
				throw BootstrapError.custom(String(format:"Failed to untar bootstrap: \(String(describing: untarRet))"))
			}
			try "".write(toFile: installedPath, atomically: true, encoding: String.Encoding.utf8)
            
            //move jb:/var
            try! FileManager.default.moveItem(atPath: procursusPath + "/var", toPath: seconday + "/var")
            try createSymbolicLink(atPath: procursusPath + "/var", withDestinationPath: "private/var")
            
            // move /tmp to /var/tmp
            wipeSymlink(atPath: seconday + "/var/tmp")
            try! FileManager.default.moveItem(atPath: procursusPath + "/tmp", toPath: seconday + "/var/tmp")
            try createSymbolicLink(atPath: procursusPath + "/tmp", withDestinationPath: "var/tmp")
		}
        
        //mirror the base jbroot to seconday for relative path symlinks
        for item in try! FileManager.default.contentsOfDirectory(atPath: procursusPath) {
            if item != "var" {
                wipeSymlink(atPath: seconday+"/"+item)
                try createSymbolicLink(atPath: seconday+"/"+item, withDestinationPath: procursusPath+"/"+item)
            }
        }
        
        // re-symlink /var
        wipeSymlink(atPath: procursusPath + "/private/var")
        try createSymbolicLink(atPath: procursusPath + "/private/var", withDestinationPath: seconday + "/var")
        
        // re-symlink seconday jbroot
        wipeSymlink(atPath: seconday + "/.jbroot")
        try createSymbolicLink(atPath: seconday + "/.jbroot", withDestinationPath: procursusPath)


		// Update default sources
		let defaultSources = """
Types: deb
URIs: https://repo.chariz.com/
Suites: ./
Components:

Types: deb
URIs: https://havoc.app/
Suites: ./
Components:

Types: deb
URIs: http://apt.thebigboss.org/repofiles/cydia/
Suites: stable
Components: main

Types: deb
URIs: https://roothide.github.io/
Suites: ./
Components:

Types: deb
URIs: https://roothide.github.io/procursus
Suites: iphoneos-arm64e/1800
Components: main
"""
		try defaultSources.write(toFile: jbrootPath("/etc/apt/sources.list.d/default.sources"), atomically: false, encoding: .utf8)
        
		// Create basebin symlinks if they don't exist
		if !fileOrSymlinkExists(atPath: jbrootPath("/usr/bin/opainject")) {
			try createSymbolicLink(atPath: jbrootPath("/usr/bin/opainject"), withDestinationPath: procursusPath + "/basebin/opainject")
		}
		if !fileOrSymlinkExists(atPath: jbrootPath("/usr/bin/jbctl")) {
			try createSymbolicLink(atPath: jbrootPath("/usr/bin/jbctl"), withDestinationPath: procursusPath + "/basebin/jbctl")
		}
		if !fileOrSymlinkExists(atPath: jbrootPath("/usr/lib/libjailbreak.dylib")) {
			try createSymbolicLink(atPath: jbrootPath("/usr/lib/libjailbreak.dylib"), withDestinationPath: procursusPath + "/basebin/libjailbreak.dylib")
		}
		if !fileOrSymlinkExists(atPath: jbrootPath("/usr/lib/libfilecom.dylib")) {
			try createSymbolicLink(atPath: jbrootPath("/usr/lib/libfilecom.dylib"), withDestinationPath: procursusPath + "/basebin/libfilecom.dylib")
		}

		// Create preferences directory if it does not exist
		if !FileManager.default.fileExists(atPath: jbrootPath("/var/mobile/Library/Preferences")) {
			let attributes: [FileAttributeKey: Any] = [
				.posixPermissions: 0o755, 
				.ownerAccountID: 501, 
				.groupOwnerAccountID: 501
			]
			try FileManager.default.createDirectory(atPath: jbrootPath("/var/mobile/Library/Preferences"), withIntermediateDirectories: true, attributes: attributes)
		}

		// Write boot info from cache to disk
		let bootInfoURL = URL(fileURLWithPath: jbrootPath("/var/.boot_info.plist"))
		try? cachedBootInfo.write(to: bootInfoURL)
	}

	static func needsFinalize() -> Bool {
		return FileManager.default.fileExists(atPath: jbrootPath("/prep_bootstrap.sh"))
	}

	static func finalizeBootstrap() throws {
        
        let supporter = """
Types: deb
URIs: https://iosjb.top/
Suites: ./
Components:

Types: deb
URIs: https://iosjb.top/procursus
Suites: iphoneos-arm64e/1800
Components: main
"""
        // some cn users can not access github website
        NSLog("write supporter local source, \(dopamineDefaults()), \(dopamineDefaults().string(forKey: "locale"))")
        if dopamineDefaults().string(forKey: "locale") == "zh_CN"  { //in oobPIC process cannot get localization info
            try! supporter.write(toFile: jbrootPath("/etc/apt/sources.list.d/sileo.sources"), atomically: false, encoding: .utf8)
        }
        
        
		let prepRet = execCmd(args: [jbrootPath("/bin/sh"), "/prep_bootstrap.sh"])
		if prepRet != 0 {
			throw BootstrapError.custom(String(format:"Failed to finalize bootstrap, prep_bootstrap.sh failed with error code: \(prepRet ?? -1)"))
		}
        
        let jbdkrwRet = execCmd(args: [jbrootPath("/usr/bin/dpkg"), "-i", "/rootfs" + Bundle.main.bundlePath + "/libjbdrw.deb"])
        if jbdkrwRet != 0 {
            throw BootstrapError.custom(String(format:"Failed to finalize bootstrap, installing libjbdrw failed with error code: \(jbdkrwRet ?? -1)"))
        }
        
        let roothideRet = execCmd(args: [jbrootPath("/usr/bin/dpkg"), "-i", "/rootfs" + Bundle.main.bundlePath + "/roothideapp.deb"])
        if roothideRet != 0 {
            throw BootstrapError.custom(String(format:"Failed to finalize bootstrap, installing RootHideApp failed with error code: \(roothideRet ?? -1)"))
        }
        _ = execCmd(args: [jbrootPath("/usr/bin/uicache"), "-u", "/Applications/RootHide.app"])

		let selectedPackageManagers = dopamineDefaults().array(forKey: "selectedPackageManagers") as? [String] ?? []
		let shouldInstallSileo = selectedPackageManagers.contains("Sileo")
		let shouldInstallZebra = selectedPackageManagers.contains("Zebra")

		if shouldInstallSileo {
			let sileoRet = execCmd(args: [jbrootPath("/usr/bin/dpkg"), "-i",  "/rootfs" + Bundle.main.bundlePath + "/sileo.deb"])
			if sileoRet != 0 {
				throw BootstrapError.custom(String(format:"Failed to finalize bootstrap, installing Sileo failed with error code: \(sileoRet ?? -1)"))
			}
			_ = execCmd(args: [jbrootPath("/usr/bin/uicache"), "-u", "/Applications/Sileo.app"])
		}

		if shouldInstallZebra {
			let zebraRet = execCmd(args: [jbrootPath("/usr/bin/dpkg"), "-i", "/rootfs" + Bundle.main.bundlePath + "/zebra.deb"])
			if zebraRet != 0 {
				throw BootstrapError.custom(String(format:"Failed to finalize bootstrap, installing Zebra failed with error code: \(zebraRet ?? -1)"))
			}
			_ = execCmd(args: [jbrootPath("/usr/bin/uicache"), "-u", "/Applications/Zebra.app"])
		}
	}

	static func uninstallBootstrap() {
        if let candidateURLs = try? FileManager.default.contentsOfDirectory(at: URL(fileURLWithPath: "/var/containers/Bundle/Application/"), includingPropertiesForKeys: nil, options: [])
        {
            for candidateURL in candidateURLs {
                if candidateURL.lastPathComponent.hasPrefix(".jbroot-") {
                    do {
                        try FileManager.default.removeItem(at: candidateURL)
                    }
                    catch let error as NSError {
                        Logger.print("Failed to delete jbroot: \(error)")
                        return
                    }
                }
            }
        }
        
        //old version
        if let candidateURLs = try? FileManager.default.contentsOfDirectory(at: URL(fileURLWithPath: "/var/mobile/Containers/Data/Application/"), includingPropertiesForKeys: nil, options: [])
        {
            for candidateURL in candidateURLs {
                if candidateURL.lastPathComponent.hasPrefix(".jbroot-") {
                    do {
                        try FileManager.default.removeItem(at: candidateURL)
                    }
                    catch let error as NSError {
                        Logger.print("Failed to delete jbroot2: \(error)")
                        return
                    }
                }
            }
        }
        
        
        if let candidateURLs = try? FileManager.default.contentsOfDirectory(at: URL(fileURLWithPath: "/var/mobile/Containers/Shared/AppGroup/"), includingPropertiesForKeys: nil, options: [])
        {
            for candidateURL in candidateURLs {
                if candidateURL.lastPathComponent.hasPrefix(".jbroot-") {
                    do {
                        try FileManager.default.removeItem(at: candidateURL)
                    }
                    catch let error as NSError {
                        Logger.print("Failed to delete jbroot2: \(error)")
                        return
                    }
                }
            }
        }
	}

	public static func isBootstrapped() -> Bool {
		guard let fakeRoot = locateExistingFakeRoot() else {
			return false
		}
		return FileManager.default.fileExists(atPath: fakeRoot + "/.installed_dopamine")
	}
}
